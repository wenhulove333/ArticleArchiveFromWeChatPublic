#我们来说说Python 第五篇 Python数据类型之数字#
这一篇我们会说下Python里面支持的数字类型，对应的操作符、处理数字的内置函数以及标准库中用于处理数字的模块。

##前言##
在进入具体Python支持的数字类型之前，我们先说下数字类型的存储特点。

数字类型是不可更改类型，也就是说变更数字的值会生成新的对象，而不会去修改原始索引的对象。

	>>> aInt = 1
	>>> id(aInt)
	30992296L
	>>> aInt += 1
	>>> id(aInt)
	30992272L

那如何去删除对象呢？在Python中，我们是无法直接删除对象，我们仅仅是删除了一个引用而已。对象的删除与否是有Python执行环境根据引用计数来确定的。一旦对象引用被删除后，是无法再继续使用的，否则会引发NameError异常。

	>>> aInt = 6
	>>> del aInt
	>>> print aInt
	
	Traceback (most recent call last):
	  File "<pyshell#6>", line 1, in <module>
	    print aInt
	NameError: name 'aInt' is not defined

了解了数字类型的存储特点后，下面一一对数字类型做说明。

##Python支持的数字类型##
###布尔型###
它只有两个值，就是布尔值True 和 布尔值 False。
###标准整型###
它是Python里面最通用的数字类型。在大多数32位机器上，标准整数类型的取值范围是-2³¹到2³¹-1，也就是-2 147 483 648 ~ 2 147 483 647。如果在64位机器上，标准整型是64位。

那如何表示标准整型呢？

有三种方式：十进制、八进制（以数字0开始）和十六进制（以0x或0X开始）。
	
	>>> a = 72
	>>> print a
	72
	>>> a = 0110
	>>> print a
	72
	>>> a = 0x48
	>>> print a
	72

###长整型###
Python里面的长整型是不能和C或其他编译型语言的长整型类型拿来做类比的。比如C里面的长整型在32位操作系统上取值范围是64位。但是Python完全不是这样，Python的长整型能够表示的数值与机器支持的（虚拟）内存大小有关，内存有多大，支持的数值就有多大。

那如何表示长整型呢？

其实和标准整型差不多，仅仅是最后加个L（大写或小写都可以）。

你可以尝试在Python交互式解释器上输入 9999999999999999999999999 **  999999999999999999999999999尝试下。

说完了标准整型和长整型，这里插入一句话，就是Python正在逐渐的统一整型和长整型，比如在最新的Python里面标准整数类型溢出会悄悄转换为长整型，同样移位也是一样的。

###双精度浮点型###
它类似于C语言中的double类型，是双精度浮点型，可以用直接的十进制或科学计数法表示。每个浮点型占8个字节，完全遵守IEEE754号规范（52M/11E/1S），其中52个位用于表示底，11个位用于表示指数，剩下的一位表示符号。

那如何表示双精度浮点型呢？

浮点型数值通常都有一个小数点和一个可选的后缀e（大写小写都可以，表示科学计数法）。在e和指数之间可以用整（+）或负（-）表示指数的正负（正数的话可以省略符号）。

4.3e25      9.384e-23

###复数###
这里我们只说Python里面复数的几个概念（其实大多数都是数学概念）以及一些例子。

- 虚数不能单独存在，它们总是和一个值为0.0的实数部分一起来构成一个复数。

- 复数由实数部分和虚数部分构成

- 表示虚数的语法：real + imagj

- 实数部分和虚数部分都是浮点数

- 虚数部分必须有后缀j或J

上面也说明了python中复数的表示。下面举几个例子。

64.375 + 23.0j

复数对象拥有数据属性，为复数的实部和虚部，另外还有一个conjugate方法（它返回该复数的共轭复数对象）。

	>>> aComplex = 98.12 + 78.23j
	>>> aComplex.real
	98.12
	>>> aComplex.imag
	78.23
	>>> aComplex.conjugate()
	(98.12-78.23j)

##Python支持的操作符##
###混合模式操作符###
其实呢这里的混合运算并非真正的混合运算，而是Python现根据一定的规则进行类型转换，然后再做运算。比如1+4.5，Python会先把1转换成浮点数，然后再做加法运算。但是数字类型的转换也不是任意的，是要符合一定的规则的，比如说一个复数类型是不可能转换成非复数类型的。

具体的规则，请参照下图。

这里有图片。

###算术操作符###
####除法####
如果大家用过C语言的话，肯定知道，对整数执行除法操作，会执行”地板除“（也就是去比商小的最大整数）。比如7/3 = 2。

但是呢，在Python里面，这种行为将要发生改变。操作符/将变为真正的除法，用新的操作符//来表示地板除。当然，这个现在还不是默认的规则，你可以通过from __future__ import division来使用这种新的规则。

	>>> 1 / 5
	0
	>>> from __future__ import division
	>>> 1 / 5
	0.2
	>>> 1 // 5
	0

####取余####
商取小于等于精确值的最大整型的乘积之差。即：x - (math.floor(x/y)*y)。

对于复数来说，不同之处在于商仅取其实数部分，即x - (math.floor((x/y).real) * y)

####幂运算####
幂运算操作符和一元操作符之间的优先级关系比较特别：幂运算操作符比其左侧操作数的一元操作符优先级低，比其右侧操作数的一元操作符的优先级高。

	>>> 10 ** -2
	0.01
	>>> -6 ** 2
	-36

####位运算符####
取反（~），按位与（&）、或（|）和异或（^），以及左移（<<）和右移（>>）。

最后，我们列出所有算术操作符的优先级（由高到低）：

> ** -+(这个是符号+)  --(这个是符号-) -** -* -/ -// -% -+ -- ->位运算符

大家主要到上面有两个**，这个是对应到我们一开始说的规则的。下面大家就理解成右面，上面就理解成左面。

其实大家也可以完全不用记优先级的顺序，只要合理的时候括号就可以了，理解起来也方便。

##内建函数和工厂函数##
这里很多函数我们前面都有提到过，比如工厂函数int()、long()、float()和complex()。再比如标准类型函数cmp()、str()和type()。

着重说下新的函数：

**abs()**   返回给定参数的绝对值；

**coerce()**  返回包含类型转换完毕的两个数值元素的元组，两个数值其中一个的类型会转换成另外一个类型；

比如：coerce(1, 4.5) 会输出 （1.0， 4.5)，其中1被转换成了浮点数。

**divmod()**  把除法和取余运算结合起来，返回一个包含商和余数的元组；

**pow() ** 执行指数运算，pow(2,5) 相当于 2 ** 5。

**round()**  用于对浮点数进行四舍五入运算，它的第二个参数是可选的，指示小数的位数，不提供的话，默认为整数。
round(3.45) 返回 3，round(3.4999, 1） 返回 3.5。

##处理数字类型的相关模块##

**decimal**     十进制浮点运算类

**array**         高效数值数组 （字符、整型、浮点型等）

**math/cmath**   标准C库数学运算函数。常规数学运算在math模块，复数运算在cmath模块

**operator**   数字操作符的函数实现，比如sub(m,n)相当于 m-n

**random**     多种伪随机数生成器

具体的细节这里就不展开详细说明，大家自行百度和谷歌。敬请期待《我们来说说Python 第六篇 Python数据类型之序列：字符串》。


