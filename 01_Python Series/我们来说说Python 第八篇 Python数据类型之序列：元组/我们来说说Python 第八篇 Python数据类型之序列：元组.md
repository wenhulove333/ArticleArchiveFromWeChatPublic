#我们来说说Python 第八篇 Python数据类型之序列：元组#
元组是跟列表非常相近的另一种容器类型。元组和列表看起来不同的一点是元组用的是圆括号而列表用的是方括号。但是它们有一个很大的区别就是**元组是一种不可变类型**。这个特点非常重要，这也是Python为什么要引入一个和列表特性特别接近的元组的原因。因为有的时候，你真的不希望别人修改你传入的数据。**非常重要！！！**

同样，由于元组和列表一样属于序列类型，因此创建元组、访问元组、更新元组和列表是一样的，请参照上一篇。同样，用于列表的操作符切片、成员关系、连接和重复操作符同样适用于元组。同样，他们的内置函数也是如此（除了那些想要做改变的操作，比如插入，删除，添加等）。这里，我们来说一些特殊的东西，这些特殊的东西都是基于元组的特点（**不可变类型**）。

##元组的特殊特性##
###不可变性给元组带来了什么影响###
我们这开篇没多久就说了这么多**不可变性**。那么一个数据类型成为不可变的到底是意味着什么呢？
在3个标准不可变类型里面（数字、字符串和元组字符串），元组受到的影响最大的，一个数据类型是不可变的，简单的讲，就意味着一旦一个对象被定义了，它的值就不能再被刷新，除非创建一个新的对象。对数字和字符串的影响不是很大，因为它们是标量类型，当他们代表的值改变时，这种结果是有意义的，是按照你所想要的方式进行访问的。而对于元组，事情就不是这样了。

因为元组是容器对象，很多时候你想改只是这个容器中的一个或多个元素。不可变的好处不言而喻，我们可以确保自己的数据的完整性。

###元组也不是那么“不可变”###
虽然元组被定义成了不可变的，但这并不影响它的灵活性。元组并不像我们想的那么不可变，这是什么意思？其实只是几个特定的行为看起来不是这么不可变。

其实我们这里说的就是连接操作和重复操作。和字符串一样，这个我们和可以认为，仅仅是连接和重复，数据还是那些数据，而下面这个，会让你大吃一惊，你可以**修改**。为什么呢？

虽然元组本身是不可变的，但这并不意味着元组包含的可变对象也不可变了。

	>>> t = ([123, 'Hello World!', 89, 9 + 8j], 23, -104.3)
	>>> t[0][0] = 45.9
	>>> print t
	([45.9, 'Hello World!', 89, (9+8j)], 23, -104.3)

虽然这不能算正真的改变，但是从某种意义上来说，我们也是改变了元组类型变量。

###默认集合类型###
所有的多对象的、逗号分隔的、没有明确用符号定义的，这些集合默认的类型都是元组。

	>>> 90, 100, 67, 93
	(90, 100, 67, 93)
	>>> x, y = 8, [1, 2]
	>>> x, y
	(8, [1, 2])

###单元素元组###
你有没有想过是否可以创建一个元素的数组？一个元素的列表是没有问题，但是元组上面就是不行。

	>>> [1]
	[1]
	>>> (1)
	1

为什么呢？因为圆括号被重载了，它也被用做分组操作符。由圆括号包裹的一个单一元素首先被作为分组操作，而不是元组的分解符。一个变通的方法是在第一个元素后面添一个逗号（,）来表明这是一个元组而不是在做分组操作。

	>>> ('xyz',)
	('xyz',)

###字典的关键字###
由于元组的不可变性，因此你可以把它作为字典的关键字。因为他们通过hash算法得到的值总是一个值，这是作为字典键值的一个必备条件。

##相关对元组进行处理的模块##

- **array**    一种受限制的可变序列类型，要求所有的元素都必须是相同的类型

- **copy**   提供浅拷贝和深拷贝的能力

- **operator**  包含函数调用形式的序列操作符，比如operator.concat(m,n)就相当于连接操作（m+n)

- **re**  Perl风格的正则表达式查找（和匹配）

- **StringIO/**  把长字符串作为文件来操作

- **cStringIO**  把长字符串当做文件夹来操作

- **textwrap**   用做包装/填充文本的函数

- **types**   包含Python支持的所有类型

- **collection**  高性能容器数据类型

说完了元组，我们的三种序列类型就都说完了。敬请期待《我们来说说Python 第九篇 Python数据类型之映射：字典》。