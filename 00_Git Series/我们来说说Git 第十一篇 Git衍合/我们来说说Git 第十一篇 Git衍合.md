#我们来说说Git 第十一篇 Git衍合#
前面我们学到一种三方合并的方法来把一个分支合并到另外一个分支，Git命令为git merge。这一篇里面我们来说下衍合（rebase）。这是一个非常有魅力的操作。下面我们一点一点揭开rebase的神秘面纱。
###基本的衍合操作###
我们还是给出一个本地仓库的一个例子，它有两个分支：master和experiment。请参考下面的图片。

这里有图片。

我们可以使用前面文章里面所讲的合并操作，把两个分支的共同祖先和两个分支最新的快照进行三方合并，产生一个新的提交对象。合并结果如下图所示。

这里有图片。

我们还可以按照这个思路去把分支experiment上的更新合并到分支master里面：把分支experiment里面产生的变化在分支master的基础打patch。这种思路我们称之为衍合。核心思想就是把要合并的分支的变化到要合入的分支上打patch，有一点要注意这里的patch是一系列的patch，从共同祖先开始后续的每一个commit都会生成相对于前面commit的一个patch.

完成这一操作，我们使用git命令：git checkout master, git rebase experiment。这样就把experiment分支上的变化以patch的形式应用到master上面。

**一旦rebase之后，分支expriment就会成为分支master的直接下游，这个和合并有着明显的差异，合并的时候experiment分支的位置并没有发生变化，只是experiment和master的共同祖先发生了变化。**

通过衍合操作，我们会发现历史记录很干净，感觉像是所有的修改都在一根线上进行。

最后我们使用merge操作把experiment衍合后的分支合入到master.

**注意**
一般来说我们使用衍合的目的是当我们和其他小伙伴合作开发时，我们一般时期望远程分支上只有一条主线分支，这样的话，后面查阅分支就会很舒服，但是我们在本地开发的时候，有不可避免的会用到分支，这个时候我们就可以在本地做衍合操作，保证所有的分支都在一根线（也就是主线的某一次commit就是某一个分支的位置），然后在提交到远程仓库。

###高阶衍合###
我们上面讲了基于共同祖先的两个分支如何进行衍合操作。现在我们来一个高阶的，两个没有共同祖先的分支进行衍合操作。

同样，我们先亮出例子。当前我们有一个主线分支master，为了修改服务器端特性我嗯增加了分支server，提交C3和C4；后续又在C3的位置增加了一个分支client,提交了C8和C9.

这里我们做一个很好玩的事情，就是先把分支client的修改放到主线里面，这里分支client时基于server分支创建，是不是很有意思。当然这里用到的git命令也是有差别的，需要用git rebase的--onto选定指定新的基底分支master.

git rebase --onto master server client

意思就是：取出分支client和分支server的共同祖先之后的变化，放到分支master上面.

现在master和server有共同祖先了，我们就可以使用git rebase server master把server分支的变化放到master上面了。最后使用merge操作快进master分支。


###衍合的风险###
任何事情都不是完美无缺的，衍合也是一样，但是你只要遵守一个守则，也不会出什么乱子：**就是不要就远程仓库的分支进行衍合操作。**

这样的话，会造成重复提交记录在代码库里面。细节这里就不说了，大家可以自己想像，推演一下。这里给个提示，你本地拉下来了远程的分支，这个时候有个家伙很讨厌，把你拉下的远程分支做了衍合操作，下一次你再去拉分支的时候，你就会认为衍合后的时一个新的分支，实际上衍合后的分支已经和你本地的分支存在重复的提交了。


到这里，我们基本上就把git涉及到的功能写的差不多了。后续我们会写一些git服务器，分布式的应用。敬请期待《我们来说说git 第十二篇 Git服务器》。
